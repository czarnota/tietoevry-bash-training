<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>presentation</title>
    <style>
    * { box-sizing: border-box; }
    .level2, h1 { max-height: 92vh; margin: 1em auto; background: #fff;
              padding: 0; font-size: 12px; aspect-ratio: 16 / 9; padding: 1.5em 1.5em 1.5em 1.5em;
              display: flex; flex-direction: column; overflow: hidden; flex: 1 1 auto;
              box-shadow: 0 0 0.5em #ddd; color: #333; }
    h1 { align-items: center; flex-direction: row; padding: 0.75em; }
    body { margin: 0; padding: 0; font-family: sans-serif; background: rgb(237, 237, 240); }
    h2 { font-size: 2em; color: #005; }
    img { display: block; margin: auto; width: 100%; height: 100%; overflow: hidden; object-fit: contain;}
    section > p, section > ul { margin: 0 0 0.8em 0; line-height: 1.5em;}
    ul { padding-left: 1em; }
    h2 { margin: 0 0 0.4em 0; }

.language-console .gp { color: #6ec071; }

/*

    Name:       Base16 Tomorrow Dark
    Author:     Chris Kempson (http://chriskempson.com)

    Pygments template by Jan T. Sott (https://github.com/idleberg)
    Created with Base16 Builder by Chris Kempson (https://github.com/chriskempson/base16-builder)

*/
.sourceCode .hll { background-color: #373b41; }

.sourceCode { background: #1d1f21; color: #ffffff; }

.sourceCode .co { color: #969896; } /* Comment */
.sourceCode .err { color: #cc6666; }

/* Error */
.sourceCode .kw { color: #b294bb; } /* Keyword */
.sourceCode .cf { color: #b294bb; } /* Keyword */
.sourceCode .l { color: #de935f; }

/* Literal */
.sourceCode .n { color: #ffffff; }

/* Name */
.sourceCode .ot { color: #8abeb7; } /* Operator */
.sourceCode .op { color: #8abeb7; } /* Operator */
.sourceCode .p { color: #ffffff; }

/* Punctuation */
.sourceCode .cm { color: #969896; }

/* Comment.Multiline */
.sourceCode .pp { color: #69AE69; } /* Comment.Preproc */
.sourceCode .im { color: #69AE69; } /* Comment.Preproc */
.sourceCode .c1 { color: #969896; }

/* Comment.Single */
.sourceCode .cs { color: #969896; }

/* Comment.Special */
.sourceCode .gd { color: #cc6666; }

/* Generic.Deleted */
.sourceCode .ge { font-style: italic; }

/* Generic.Emph */
.sourceCode .gh { color: #ffffff; font-weight: bold; }

/* Generic.Heading */
.sourceCode .gi { color: #b5bd68; }

/* Generic.Inserted */
.sourceCode .gp { color: #969896; font-weight: bold; }

/* Generic.Prompt */
.sourceCode .gs { font-weight: bold; } 
/* Generic.Strong */
.sourceCode .gu { color: #8abeb7; font-weight: bold; }

/* Generic.Subheading */
.sourceCode .kc { color: #b294bb; }

/* Keyword.Constant */
.sourceCode .kd { color: #b294bb; }

/* Keyword.Declaration */
.sourceCode .kn { color: #8abeb7; }

/* Keyword.Namespace */
.sourceCode .kp { color: #b294bb; }

/* Keyword.Pseudo */
.sourceCode .kr { color: #b294bb; }

/* Keyword.Reserved */
.sourceCode .dt { color: #f0c674; } /* Keyword.Type */
.sourceCode .ld { color: #b5bd68; }

/* Literal.Date */
.sourceCode .m { color: #de935f; }

/* Literal.Number */
.sourceCode .s { color: #b5bd68; }

/* Literal.String */
.sourceCode .na { color: #81a2be; }

/* Name.Attribute */
.sourceCode .bu { color: #ffffff; } /* Name.Builtin */
.sourceCode .nc { color: #f0c674; }

/* Name.Class */
.sourceCode .no { color: #cc6666; }

/* Name.Constant */
.sourceCode .nd { color: #8abeb7; }

/* Name.Decorator */
.sourceCode .ni { color: #ffffff; }

/* Name.Entity */
.sourceCode .ne { color: #cc6666; }

/* Name.Exception */
.sourceCode .fu { color: #81a2be; } /* Name.Function */

/* Name.Label */
.sourceCode .nn { color: #f0c674; }

/* Name.Namespace */
.sourceCode .nx { color: #81a2be; }

/* Name.Other */
.sourceCode .py { color: #ffffff; }

/* Name.Property */
.sourceCode .nt { color: #8abeb7; }

/* Name.Tag */
.sourceCode .va { color: #cc6666; } /* Name.Variable */
.sourceCode .ow { color: #8abeb7; }

/* Operator.Word */
.sourceCode .w { color: #ffffff; }

/* Text.Whitespace */
.sourceCode .mf { color: #de935f; }

/* Literal.Number.Float */
.sourceCode .mh { color: #de935f; }

/* Literal.Number.Hex */
.sourceCode .dv { color: #de935f; }

/* Literal.Number.Integer */
.sourceCode .mo { color: #de935f; }

/* Literal.Number.Oct */
.sourceCode .sb { color: #b5bd68; }

/* Literal.String.Backtick */
.sourceCode .sc { color: #ffffff; }

/* Literal.String.Char */
.sourceCode .sd { color: #969896; }

/* x Literal.String.Doc */
.sourceCode .st { color: #b5bd68; }

/* Literal.String.Double */
.sourceCode .sc { color: #de935f; } 
/* Literal.String.Escape */
.sourceCode .sh { color: #b5bd68; }

/* Literal.String.Heredoc */
.sourceCode .si { color: #de935f; }

/* Literal.String.Interpol */
.sourceCode .sx { color: #b5bd68; }

/* Literal.String.Other */
.sourceCode .sr { color: #b5bd68; }

/* Literal.String.Regex */
.sourceCode .s1 { color: #b5bd68; }

/* Literal.String.Single */
.sourceCode .ss { color: #b5bd68; }

/* Literal.String.Symbol */
.sourceCode .bp { color: #ffffff; }

/* Name.Builtin.Pseudo */
.sourceCode .vc { color: #cc6666; }

/* Name.Variable.Class */
.sourceCode .vg { color: #cc6666; }

/* Name.Variable.Global */
.sourceCode .vi { color: #cc6666; }

/* Name.Variable.Instance */
.sourceCode .il { color: #de935f; }

/* Literal.Number.Integer.Long */

div.sourceCode { vertical-align: top; margin: 0 0 0.8em 0; }

pre {
  font-family: monospace;
  font-size: 0.8em;
  margin: 0 0 0.8em 0;
}

.sourceCode a { color: #fff }

.sourceCode pre {
    padding: 0;
    margin: 0;
}

pre code {
  display: block;
  padding: 1em 1.25em;
  overflow-x: auto;
  background: #1d1f21;
  color: #ffffff;
}
      .sourceCode pre code::-webkit-scrollbar {
        -webkit-appearance: none; }
      .sourceCode pre code::-webkit-scrollbar:vertical {
        width: 10px; }
      .sourceCode pre code::-webkit-scrollbar:horizontal {
        height: 10px; }
      .sourceCode pre code::-webkit-scrollbar-thumb {
        background-color: #555; }
      .sourceCode pre code::-webkit-scrollbar-track {
        background-color: #333; }
  .sourceCode::selection {
    background: #fff;
    /* WebKit/Blink Browsers */
    color: #000; }
  .sourceCode::-moz-selection {
    background: #fff;
    /* Gecko Browsers */
    color: #000; }

p > code, li > code {
  background: #fff;
  padding: 0.1em 0.2em;
  box-shadow: 0 2px 4px 0 #ddd;
  border: 1px solid #ddd; }

    </style>
    <link rel="stylesheet" href="assets/styles.css" />
  </head>
  <body>
<section id="bash-training" class="level1">
<h1>Bash training</h1>
<section id="bash" class="level2">
<h2>Bash</h2>
<p>Bash is an Unix shell and command language written for the GNU Project</p>
<p><img src="assets/bash.png" /></p>
</section>
<section id="system-shell" class="level2">
<h2>System shell</h2>
<p><strong>System shell</strong> is a computer program, which acts as an interface between operating system, applications and the user. Using the shell, user can interact with the operating system e.g. <strong>run processes</strong>, perform operations on files, change system settings etc.</p>
<p><img src="assets/0.svg" /></p>
</section>
<section id="examples-of-system-shells---windows-file-explorer" class="level2">
<h2>Examples of system shells - Windows File Explorer</h2>
<p>File Explorer is an application, which allows user to open files and run processes. It is an example of a graphical system shell.</p>
<p><img src="assets/fileexplorer.jpg" /></p>
</section>
<section id="examples-of-system-shells---xbox-series-x-dashboard" class="level2">
<h2>Examples of system shells - Xbox Series X dashboard</h2>
<p>The purpose of Xbox dashboard is to run processes (games), therefore it can also be considered as an example of graphical system shell.</p>
<p><img src="assets/xoneshell.jpg" /></p>
</section>
<section id="examples-of-system-shells---bash" class="level2">
<h2>Examples of system shells - Bash</h2>
<p>Bash is an example of a command-line shell. Other example of command line shells include i. a.: <code>zsh</code>, <code>tcsh</code>, <code>busybox ash</code> and <code>fish</code> shell</p>
<p><img src="assets/bashshell.png" /></p>
</section>
<section id="question-why-do-we-still-use-a-command-line-interface" class="level2">
<h2>Question: Why do we still use a command-line interface?</h2>
<p>Why in the era of graphical user interfaces and amazing user experiences programmers still work using the “ancient” command line interface?</p>
<ul class="incremental">
<li>Do they want to show off?</li>
<li>Are they nerds?</li>
<li>Are they insance people?</li>
</ul>
</section>
<section id="answer-why-do-we-still-use-a-command-line-interface" class="level2">
<h2>Answer: Why do we still use a command-line interface?</h2>
<ul class="incremental">
<li><strong>It is easier to show what you did to others</strong>. You can send a list of commands to the other person instead of screenshots.</li>
<li><strong>It is natural to automate</strong>. What you type can be placed in a text file and you can run it again.</li>
<li><strong>It is faster to write command line applications</strong>. Compare <code>echo hello world</code> with a “Hello World application” in any GUI framework.</li>
</ul>
</section>
<section id="running-programs" class="level2">
<h2>Running programs</h2>
<p>Using Bash system shell we can run processes by typing program names.</p>
<pre class="console"><code>$ PROGRAM_NAME ARGUMENTS...</code></pre>
<p>For example if we want to run a <code>ls</code> program, we can type:</p>
<pre><code>$ ls -l -a /home</code></pre>
</section>
<section id="example-programs---filesystem-operations" class="level2">
<h2>Example programs - filesystem operations</h2>
<p>Examples of programs that manage files and directories</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="fu">cat</span> p0             <span class="co"># print p0 to standard output</span></a>
<a class="sourceLine" id="cb3-2" title="2">$ <span class="fu">cat</span> p0 p1 p2       <span class="co"># print p0, p1 and p2 to standard output</span></a>
<a class="sourceLine" id="cb3-3" title="3">$ <span class="fu">rm</span> x               <span class="co"># remove file</span></a>
<a class="sourceLine" id="cb3-4" title="4">$ <span class="fu">rm</span> -fr a           <span class="co"># remove file or directory &quot;recursively&quot;</span></a>
<a class="sourceLine" id="cb3-5" title="5">$ <span class="fu">ls</span> d0              <span class="co"># print a list of files in &#39;d0&#39; directory</span></a>
<a class="sourceLine" id="cb3-6" title="6">$ <span class="fu">ls</span> -a d0           <span class="co"># print a list of files in &#39;d0&#39; directory including hidden files</span></a>
<a class="sourceLine" id="cb3-7" title="7">$ <span class="fu">ls</span> -l d0           <span class="co"># print a more detailed list of files in &#39;d0&#39; directory</span></a>
<a class="sourceLine" id="cb3-8" title="8">$ <span class="fu">mv</span> a b             <span class="co"># rename file from &#39;a&#39; to &#39;b&#39;</span></a>
<a class="sourceLine" id="cb3-9" title="9">$ <span class="fu">cp</span> a b             <span class="co"># copy &#39;a&#39; file to &#39;b&#39;</span></a>
<a class="sourceLine" id="cb3-10" title="10">$ <span class="fu">cp</span> -r a b          <span class="co"># copy &#39;a&#39; directory to &#39;b&#39; recursively</span></a>
<a class="sourceLine" id="cb3-11" title="11">$ <span class="fu">cp</span> a b c d         <span class="co"># copy &#39;a&#39;, &#39;b&#39;, &#39;c&#39; into &#39;d&#39; directory</span></a>
<a class="sourceLine" id="cb3-12" title="12">$ <span class="fu">touch</span> x            <span class="co"># change &#39;x&#39; file timestamps</span></a>
<a class="sourceLine" id="cb3-13" title="13">$ <span class="fu">touch</span> -c x         <span class="co"># change &#39;x&#39; file timestamps, but do not create a file</span></a>
<a class="sourceLine" id="cb3-14" title="14">$ <span class="fu">mkdir</span> a            <span class="co"># create directory name &#39;a&#39;</span></a>
<a class="sourceLine" id="cb3-15" title="15">$ <span class="fu">mkdir</span> -p a/b/c     <span class="co"># create &#39;a/b/c&#39; directory hierarchy</span></a>
<a class="sourceLine" id="cb3-16" title="16">$ <span class="fu">rmdir</span> a            <span class="co"># remove empty directory</span></a>
<a class="sourceLine" id="cb3-17" title="17">$ <span class="fu">ln</span> a b             <span class="co"># create hard link named &#39;b&#39; to &#39;a&#39;</span></a>
<a class="sourceLine" id="cb3-18" title="18">$ <span class="fu">ln</span> -s a b          <span class="co"># create soft link named &#39;b&#39; to &#39;a&#39;</span></a></code></pre></div>
</section>
<section id="example-programs---access-control" class="level2">
<h2>Example programs - access control</h2>
<p>Examples of programs that manage file and directory permissions</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1">$ <span class="fu">chmod</span> 777 f        <span class="co"># change &#39;f&#39; permissions to 777</span></a>
<a class="sourceLine" id="cb4-2" title="2">$ <span class="fu">chmod</span> u+x,g+x,o+x  <span class="co"># add execute permission to user, group and others</span></a>
<a class="sourceLine" id="cb4-3" title="3">$ <span class="fu">chown</span> user a       <span class="co"># change owner of &#39;a&#39; to &#39;user&#39;</span></a>
<a class="sourceLine" id="cb4-4" title="4">$ <span class="fu">chown</span> group:user a <span class="co"># change group to &#39;gruop&#39; and owner of &#39;a&#39; to &#39;user&#39;</span></a></code></pre></div>
</section>
<section id="example-programs---archive-management" class="level2">
<h2>Example programs - archive management</h2>
<p>Examples of programs that manage archives</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1">$ <span class="fu">tar</span> -tf archive.tar.gz             <span class="co"># print (t) files in archive (f)</span></a>
<a class="sourceLine" id="cb5-2" title="2">$ <span class="fu">tar</span> -xzvf archive.tar.gz           <span class="co"># extract (x) .gz (z) archive, verbosely (v)</span></a>
<a class="sourceLine" id="cb5-3" title="3">$ <span class="fu">tar</span> -xjvf archive.tar.bz2 -C dir   <span class="co"># extract (x) .bz2 (j) archive, verbosely (v) to &#39;dir&#39;</span></a>
<a class="sourceLine" id="cb5-4" title="4">$ <span class="fu">tar</span> -cf archive.tar f1 f2 d0       <span class="co"># create (c) tar archive with files (f) f1 f2 d0</span></a>
<a class="sourceLine" id="cb5-5" title="5">$ <span class="fu">tar</span> -cjvpf archive.tar.bz2 f1 f2   <span class="co"># create bz2 (j) verbosely (v), preserving permissions (p)</span></a>
<a class="sourceLine" id="cb5-6" title="6">$ <span class="fu">zip</span> x.zip f0                       <span class="co"># create &#39;x.zip&#39; archive containing &#39;f0&#39; file</span></a>
<a class="sourceLine" id="cb5-7" title="7">$ <span class="fu">zip</span> -r x.zip d0                    <span class="co"># create &#39;x.zip&#39; archive containing &#39;d0&#39; directory</span></a>
<a class="sourceLine" id="cb5-8" title="8">$ <span class="fu">unzip</span> x.zip                        <span class="co"># unzip &#39;x.zip&#39;</span></a>
<a class="sourceLine" id="cb5-9" title="9">$ <span class="fu">unzip</span> -l x.zip                     <span class="co"># print files in &#39;x.zip&#39; archive</span></a></code></pre></div>
</section>
<section id="question-what-is-the-difference-between-a-symbolic-link-and-a-hard-link" class="level2">
<h2>Question: What is the difference between a symbolic link and a hard link?</h2>
<p>We can create symbolic links using <code>ln</code> program:</p>
<pre class="console"><code>$ ln target destination</code></pre>
<p>We can create hard links using <code>ln</code> program:</p>
<pre class="console"><code>$ ln -s target destination</code></pre>
<p>What is the difference?</p>
</section>
<section id="answer-what-is-the-difference-between-a-symbolic-link-and-a-hard-link" class="level2">
<h2>Answer: What is the difference between a symbolic link and a hard link?</h2>
<pre><code>$ ln bar foo</code></pre>
<pre><code>$ ln -s bar baz</code></pre>
<p><img src="assets/1.svg" /></p>
</section>
<section id="task-the-land-of-tietoevry" class="level2">
<h2>Task: The Land of TietoEvry</h2>
<p>Download the following archive using <code>wget</code> program:</p>
<pre><code>$ wget czarnota.github.io/bashtraining/task-land.tar.gz</code></pre>
<ol class="incremental" type="1">
<li>Extract the archive</li>
<li>Complete all listed missions</li>
<li>Create a <code>.tar.gz</code> archive from the directory</li>
</ol>
</section>
</section>
<section id="options-and-arguments" class="level1">
<h1>Options and arguments</h1>
<section id="options-and-arguments-1" class="level2">
<h2>Options and arguments</h2>
<p>All characters (with the exception of a few built-in bash constructs/operators) following the program’s name are interpreted by the program and can influence its behavior.</p>
<pre class="console"><code>$ PROGRAM_NAME ARGUMENTS...</code></pre>
<pre class="console"><code>$ chmod o+w,g+w file</code></pre>
<pre class="console"><code>$ find . \( -name words -or -name x \) -and -not -executable</code></pre>
<pre class="console"><code>$ tcpdump -i eth0 ip or arp</code></pre>
</section>
<section id="posix-syntax" class="level2">
<h2>POSIX Syntax</h2>
<p>Programs can parse options and arguments as they like, but there exists a common convention that most unix programs follow. This convention is standarised by POSIX.</p>
<p>In below example <code>-a</code> is an option, <code>-b barg</code> is an option with an argument <code>barg</code> and <code>arg0</code> and <code>arg1</code> are just arguments.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1">$ <span class="ex">prog</span> -a -b barg arg0 arg1 <span class="co"># The &#39;barg&#39; is an argument to -b option</span></a>
<a class="sourceLine" id="cb15-2" title="2">$ <span class="ex">prog</span> -ab barg arg0 arg1   <span class="co"># You can &quot;glue&quot; options together</span></a>
<a class="sourceLine" id="cb15-3" title="3">$ <span class="ex">prog</span> -a -- -b barg arg1   <span class="co"># You can terminate options using --, here -b is an argument</span></a></code></pre></div>
<p>For example, the below two commands are equivalent:</p>
<pre class="console"><code>$ tar -x -z -v -f arch.tar.gz 
$ tar -xzvfarch.tar.gz</code></pre>
</section>
<section id="extended-gnu-syntax" class="level2">
<h2>Extended GNU Syntax</h2>
<p>GNU introduced long options (supported using <code>getopt_long()</code> and <code>getopt_long_only()</code> C library functions)</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1">$ <span class="ex">prog</span> -ab --option --key=value arg0 arg1 arg2   <span class="co"># getopt_long()</span></a>
<a class="sourceLine" id="cb17-2" title="2">$ <span class="ex">prog</span> -option -key arg0 arg1 arg2               <span class="co"># getopt_long_only()</span></a></code></pre></div>
<p>Examples of long options</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1">$ <span class="fu">ps</span> --user             <span class="co"># getopt_long()</span></a>
<a class="sourceLine" id="cb18-2" title="2">$ <span class="fu">ls</span> --all              <span class="co"># getopt_long()</span></a>
<a class="sourceLine" id="cb18-3" title="3">$ <span class="fu">find</span> . -name x        <span class="co"># getopt_long_only()</span></a></code></pre></div>
</section>
<section id="legacy-bsd-syntax" class="level2">
<h2>Legacy BSD Syntax</h2>
<p>Something that <code>ps</code> manual page calls a <code>BSD Syntax</code>. It is supported only by a few programs</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" title="1">$ <span class="ex">prog</span> ab arg0 arg1 arg2     <span class="co"># options are: &#39;a&#39; and &#39;b&#39;, the rest are arguments</span></a>
<a class="sourceLine" id="cb19-2" title="2">$ <span class="ex">prog</span> abcdef arg0 arg1 arg2 <span class="co"># options are: &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, the rest are arguments</span></a></code></pre></div>
<p>Examples</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1">$ <span class="fu">ps</span> aux</a>
<a class="sourceLine" id="cb20-2" title="2">$ <span class="fu">tar</span> xzvf arch.tar.gz</a>
<a class="sourceLine" id="cb20-3" title="3">$ <span class="fu">tar</span> czf files.tar.gz file1 file2</a></code></pre></div>
</section>
<section id="command-syntax---conclusion" class="level2">
<h2>Command syntax - conclusion</h2>
<p>It is important to note that the options and arguments are interpreted by the executed program and not by the shell. For example, if we execute <code>ls</code></p>
<pre><code>$ ls -l -a /home</code></pre>
<p>Then the <code>ls</code> program would receive the following arguments in its <code>main()</code> function.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)</a>
<a class="sourceLine" id="cb22-2" title="2">{</a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="co">// argv = { &quot;ls&quot;, &quot;-l&quot;, &quot;-a&quot;, &quot;/home&quot; }</span></a>
<a class="sourceLine" id="cb22-4" title="4">    <span class="co">// argc = 4</span></a>
<a class="sourceLine" id="cb22-5" title="5">    ...</a>
<a class="sourceLine" id="cb22-6" title="6">}</a></code></pre></div>
<p><strong>Bash only splits the input line into tokens</strong></p>
</section>
<section id="question-which-is-correct" class="level2">
<h2>Question: Which is correct?</h2>
<p>Which commands would you use to create directory called <code>-f</code>, list its contents and then remove it afterwards?</p>
<p>These commands:</p>
<pre class="console"><code>$ mkdir -f
$ ls -f
$ rm -fr -f</code></pre>
<p>Or these:</p>
<pre class="console"><code>$ mkdir &quot;-f&quot;
$ ls &quot;-f&quot;
$ rm -fr &quot;-f&quot;</code></pre>
</section>
<section id="answer-which-is-correct" class="level2">
<h2>Answer: Which is correct?</h2>
<p>Neither. The quotes <code>""</code> make no difference to the executed program. It will still see <code>-f</code> in its argument list. We need to use <code>--</code> to terminate the list of options.</p>
<pre class="console"><code>$ mkdir -- &quot;-f&quot;
$ ls -- &quot;-f&quot;
$ rm -fr -- &quot;-f&quot;</code></pre>
</section>
<section id="example-programs---find" class="level2">
<h2>Example programs - find</h2>
<p>The <code>find</code> program searches for files or directories. For example to find all files named <code>lib_functions.c</code> starting our search from the current working directory <code>.</code>, we can do:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb26-1" title="1">$ <span class="fu">find</span> . -name <span class="st">&quot;lib_functions.c&quot;</span></a></code></pre></div>
<p>We can search in a case insensitive mode, also using wildcard patterns. The below example will print all files that start with string <code>host</code> (case insensitive). Also it will not print any directories <code>-type f</code></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb27-1" title="1">$ <span class="fu">find</span> / -iname <span class="st">&quot;host*&quot;</span> -type f</a></code></pre></div>
<p>We can execute a program on each file with <code>.tmp</code> extension. The below command will remove all <code>.tmp</code> files, but will prompt for confirmation before removal (<code>rm -i</code>).</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb28-1" title="1">$ <span class="fu">find</span> . -name <span class="st">&quot;*.tmp&quot;</span> -exec rm -i {} <span class="dt">\;</span></a></code></pre></div>
</section>
<section id="task-svg-to-png-converter" class="level2">
<h2>Task: SVG to PNG converter</h2>
<p>Download and extract, using the terminal.</p>
<pre><code>https://github.com/simple-icons/archive/develop.zip</code></pre>
<ol class="incremental" type="1">
<li>Convert all <code>.svg</code> icons starting <strong>with the same letter as your surname</strong> into <code>.png</code> files.</li>
<li>Pack converted files into a <code>.zip</code> archive</li>
</ol>
<p>Hints:</p>
<ul class="incremental">
<li><code>find</code> - will allow you to execute a program on selected files;</li>
<li><code>inkscape</code> - will allow you to convert <code>.svg</code> to <code>.png</code>;</li>
<li><code>zip</code> - will allow you to create a <code>.zip</code> archive.</li>
</ul>
</section>
</section>
<section id="processes" class="level1">
<h1>Processes</h1>
<section id="the-difference-between-a-program-and-a-process" class="level2">
<h2>The difference between a program and a process</h2>
<p>A process is a program that is being executed</p>
<p>Program is a list of instructions to be executed (just like a cooking recipe) and a process is an act of executing these instructions (just like cooking). <img src="assets/programandprocess.png" /></p>
</section>
<section id="what-is-a-proces" class="level2">
<h2>What is a proces</h2>
<p>A process is a program that is being executed. It consists of:</p>
<ul class="incremental">
<li><strong>Processor state (registers)</strong> For <code>x86_64</code> these are i. a:
<ul class="incremental">
<li><code>rbp</code> - base of the stack (frame pointer)</li>
<li><code>rsp</code> - stack pointer</li>
<li><code>rip</code> - program counter</li>
<li><code>rflags</code> - flags register</li>
<li>general purpose registers: <code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rbx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>-<code>r15</code></li>
</ul></li>
<li><strong>Virtual memory</strong> (Page table) (pointer by <code>CR3</code> register)</li>
<li><strong>Open file descriptors</strong>, for example:
<ul class="incremental">
<li>regular files (opened by <code>open()</code>)</li>
<li>network sockets (opened by <code>socket()</code>, <code>accept()</code>)</li>
<li>pipes (opened by <code>pipe()</code>)</li>
</ul></li>
<li>Other data structure important for Linux kernel</li>
</ul>
</section>
<section id="how-linux-represents-processes" class="level2">
<h2>How Linux represents processes?</h2>
<p>In Linux kernel every process is represented by a <code>struct task_struct</code></p>
<p>Below are some fields in this structure:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">struct</span> task_struct {</a>
<a class="sourceLine" id="cb30-2" title="2">    <span class="kw">struct</span> list_head tasks           <span class="co">/* An entry on a process list */</span></a>
<a class="sourceLine" id="cb30-3" title="3">    pid_t pid;                       <span class="co">/* Process identifies (PID)  */</span></a>
<a class="sourceLine" id="cb30-4" title="4">    <span class="kw">struct</span> mm_struct *mm             <span class="co">/* Process memory */</span></a>
<a class="sourceLine" id="cb30-5" title="5">    <span class="kw">struct</span> task_struct *real_parent; <span class="co">/* The real parent - the one who called clone() */</span></a>
<a class="sourceLine" id="cb30-6" title="6">    <span class="kw">struct</span> task_struct *parent;      <span class="co">/* Receiver of SIGCHLD i wait4() */</span></a>
<a class="sourceLine" id="cb30-7" title="7">    <span class="kw">struct</span> list_head children;       <span class="co">/* Process&#39; children */</span></a>
<a class="sourceLine" id="cb30-8" title="8">    <span class="kw">struct</span> sigpending pending;       <span class="co">/* List of pending signals */</span></a>
<a class="sourceLine" id="cb30-9" title="9">    <span class="kw">struct</span> files_struct *files;      <span class="co">/* Open file descriptors */</span></a>
<a class="sourceLine" id="cb30-10" title="10">    <span class="dt">void</span> *stack                      <span class="co">/* Pointer to kernel stack of the process </span></a>
<a class="sourceLine" id="cb30-11" title="11"><span class="co">                                        - on x86_64 the state of registers is</span></a>
<a class="sourceLine" id="cb30-12" title="12"><span class="co">                                          stored here */</span></a>
<a class="sourceLine" id="cb30-13" title="13">    ...</a>
<a class="sourceLine" id="cb30-14" title="14">};</a></code></pre></div>
</section>
<section id="process-list" class="level2">
<h2>Process list</h2>
<p>Linux internally keeps a circular list of all processes running in the system.</p>
<p><img src="assets/12.svg" /></p>
</section>
<section id="how-can-we-check-which-processes-are-running-at-the-moment" class="level2">
<h2>How can we check which processes are running at the moment</h2>
<p>The <code>ps</code> program can show us all processes, the <code>top</code> program display processes interactively, the <code>pstree</code> prints a tree of processes and the pseudo file system <code>/proc</code> contains entries representing every process.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb31-1" title="1">$ <span class="fu">ps</span> aux</a></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb32-1" title="1">$ <span class="ex">top</span></a></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb33-1" title="1">$ <span class="fu">pstree</span></a></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb34-1" title="1">$ <span class="fu">ls</span> /proc</a></code></pre></div>
</section>
<section id="running-processes-in-bash---how-does-it-work" class="level2">
<h2>Running processes in Bash - how does it work</h2>
<p>A primitive system shell could be implemented like this:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="cf">while</span> (true) {</a>
<a class="sourceLine" id="cb35-2" title="2">    <span class="dt">char</span> *line = readline(<span class="st">&quot;$ &quot;</span>);</a>
<a class="sourceLine" id="cb35-3" title="3">    <span class="dt">char</span> *my_argv[<span class="dv">12</span>] = {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb35-4" title="4">    <span class="cf">if</span> (!parse_line(line, my_argv, ARRAY_SIZE(my_argv) - <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb35-5" title="5">        <span class="cf">goto</span> out;</a>
<a class="sourceLine" id="cb35-6" title="6"></a>
<a class="sourceLine" id="cb35-7" title="7">    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb35-8" title="8">    <span class="cf">if</span> (pid == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb35-9" title="9">        execvp(my_argv[<span class="dv">0</span>], my_argv);</a>
<a class="sourceLine" id="cb35-10" title="10"></a>
<a class="sourceLine" id="cb35-11" title="11">    <span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb35-12" title="12">    waitpid(pid, &amp;status, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb35-13" title="13">    report(status);</a>
<a class="sourceLine" id="cb35-14" title="14">out:</a>
<a class="sourceLine" id="cb35-15" title="15">    free(line);</a>
<a class="sourceLine" id="cb35-16" title="16">}</a></code></pre></div>
</section>
<section id="running-processes-in-background" class="level2">
<h2>Running processes in background</h2>
<p>In <code>ls &amp;</code> command, the <code>&amp;</code> will run the process in the background. It omits the call to <code>waitpid()</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="cf">while</span> (true) {</a>
<a class="sourceLine" id="cb36-2" title="2">    <span class="dt">char</span> *line = readline(<span class="st">&quot;$ &quot;</span>);</a>
<a class="sourceLine" id="cb36-3" title="3">    <span class="dt">char</span> *my_argv[<span class="dv">12</span>] = {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb36-4" title="4">    <span class="cf">if</span> (!parse_line(line, my_argv, ARRAY_SIZE(my_argv) - <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb36-5" title="5">        <span class="cf">goto</span> out;</a>
<a class="sourceLine" id="cb36-6" title="6">    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb36-7" title="7">    <span class="cf">if</span> (pid == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb36-8" title="8">        execvp(my_argv[<span class="dv">0</span>], my_argv);</a>
<a class="sourceLine" id="cb36-9" title="9">    <span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb36-10" title="10">    <span class="cf">if</span> (in_background(line))</a>
<a class="sourceLine" id="cb36-11" title="11">        status = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb36-12" title="12">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb36-13" title="13">        waitpid(pid, &amp;status, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb36-14" title="14">    report(status);</a>
<a class="sourceLine" id="cb36-15" title="15">out:</a>
<a class="sourceLine" id="cb36-16" title="16">    free(line);</a>
<a class="sourceLine" id="cb36-17" title="17">}</a></code></pre></div>
</section>
<section id="question-if-we-omit-waitpid-and-bash-is-still-running-why-there-are-no-zombie-processes" class="level2">
<h2>Question: If we omit <code>waitpid()</code> and bash is still running, why there are no zombie processes?</h2>
<p>After all, this is how zombie processes are created.</p>
<p>What are we missing?</p>
</section>
<section id="answer-if-we-omit-waitpid-and-bash-is-still-running-why-there-are-no-zombie-processes" class="level2">
<h2>Answer: If we omit <code>waitpid()</code> and bash is still running, why there are no zombie processes?</h2>
<p>When a child process finishes, the parent is notified with <code>SIGCHLD</code>. Bash calls <code>wait</code> system call in <code>SIGCHLD</code> handler, which allows to read process exit code and remove it from list of processes.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="co">/* sigchld_handler () flushes at least one of the children that we are</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="co">   waiting for.  It gets run when we have gotten a SIGCHLD signal. */</span></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="dt">static</span> sighandler sigchld_handler(<span class="dt">int</span> sig) {</a>
<a class="sourceLine" id="cb37-4" title="4">    <span class="dt">int</span> n, oerrno;</a>
<a class="sourceLine" id="cb37-5" title="5">    oerrno = errno;</a>
<a class="sourceLine" id="cb37-6" title="6">    REINSTALL_SIGCHLD_HANDLER;</a>
<a class="sourceLine" id="cb37-7" title="7">    sigchld++;</a>
<a class="sourceLine" id="cb37-8" title="8">    n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb37-9" title="9">    <span class="cf">if</span> (queue_sigchld == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb37-10" title="10">        n = waitchld (-<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb37-11" title="11">    errno = oerrno;</a>
<a class="sourceLine" id="cb37-12" title="12">    SIGRETURN (n);</a>
<a class="sourceLine" id="cb37-13" title="13">}</a></code></pre></div>
</section>
<section id="question-will-zombie-process-be-created" class="level2">
<h2>Question: Will zombie process be created?</h2>
<p>The <code>exec</code> command calls one of <code>exec*()</code> system calls, which causes current process to execute different program, by replacing the code section of the current process and reinitializing process memory.</p>
<p>The <code>/usr/bin/sleep</code> simply wait the specified number of seconds</p>
<p>The questions are:</p>
<ul class="incremental">
<li><strong>Will zombie process be created in the below case?</strong></li>
<li><strong>If so, then why will it be created?</strong></li>
<li><strong>If so, how long will it exist in a zombie state?</strong></li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb38-1" title="1">$ <span class="ex">/usr/bin/sleep</span> 5 <span class="kw">&amp;</span>        </a>
<a class="sourceLine" id="cb38-2" title="2">$ <span class="bu">exec</span> /usr/bin/sleep 3600</a></code></pre></div>
</section>
<section id="answer-will-zombie-process-be-created" class="level2">
<h2>Answer: Will zombie process be created?</h2>
<div class="sourceCode" id="cb39"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb39-1" title="1">$ <span class="ex">/usr/bin/sleep</span> 5 <span class="kw">&amp;</span>         <span class="co"># spawn child</span></a>
<a class="sourceLine" id="cb39-2" title="2">$ <span class="bu">exec</span> /usr/bin/sleep 3600   <span class="co"># replace bash with sleep - erases signal handler</span></a></code></pre></div>
<p>Answers:</p>
<ul class="incremental">
<li><strong>Will zombie process be created in the below case?</strong>
<ul class="incremental">
<li>Yes.</li>
</ul></li>
<li><strong>Why it will be created</strong>
<ul class="incremental">
<li>Because <code>sleep</code> does not implement <code>SIGCHLD</code> signal handler.</li>
</ul></li>
<li><strong>How long will it exist in a zombie state</strong>
<ul class="incremental">
<li>The child executes for <code>5</code> seconds, the parent <code>3600</code> seconds. The child will be in zombie state <code>3595</code> seconds.</li>
</ul></li>
</ul>
</section>
<section id="detaching-processes-from-the-shell" class="level2">
<h2>Detaching processes from the shell</h2>
<p>Runs <code>COMMAND</code>, redirects <code>stdout</code> and <code>stderr</code> to files in order to avoid termination from closed terminal and removes the <code>PID</code> from bash job list, which will prevent bash from propagating <code>SIGHUP</code>.</p>
<pre><code>$ COMMAND &gt;file 2&gt;file &amp;
$ disown PID</code></pre>
<p>Runs <code>COMMAND</code>, but prevents it from receiving <code>SIGHUP</code>, also redirects the <code>stdin</code> and <code>stdout</code>.</p>
<pre><code>$ nohup COMMAND &amp;</code></pre>
<p>Runs process with the help of <code>screen</code> program, which thanks to <code>-d</code> option will disconnect itself from the <code>bash</code> process.</p>
<pre><code>$ screen -d -m COMMAND</code></pre>
</section>
<section id="example-programs---watch" class="level2">
<h2>Example programs - <code>watch</code></h2>
<p>Executes a program periodically, showing output fullscreen.</p>
<p>Show processes periodically:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb43-1" title="1">$ <span class="ex">watch</span> ps aux</a></code></pre></div>
<p>Show memory usage in real time:</p>
<pre class="bas"><code>$ watch -n0 df</code></pre>
</section>
<section id="task-detaching-from-the-terminal" class="level2">
<h2>Task: Detaching from the terminal</h2>
<ol class="incremental" type="1">
<li>Run <code>tar</code> program so that it would compress the selected directory located in home directory into <code>~/archive.tar.gz</code> every minute. The process should not be terminated after closing the terminal.</li>
<li>If the process survived after closing the terminal, kill it with <code>kill</code> program.</li>
</ol>
<p>You can get the <code>PID</code> of the process using <code>ps</code> program or <code>pidof</code>.</p>
</section>
</section>
<section id="input-and-output" class="level1">
<h1>Input and output</h1>
<section id="wielozadaniowość-na-wielu-procesorachrdzeniach" class="level2">
<h2>Wielozadaniowość na wielu procesorach/rdzeniach</h2>
<p>W przypadku wielu procesorów, system operacyjny może uruchamiać procesy rzeczywiście równolegle</p>
<p><img src="assets/7.svg" /></p>
</section>
<section id="wielozadaniowość-na-wielu-procesorachrdzeniach-1" class="level2">
<h2>Wielozadaniowość na wielu procesorach/rdzeniach</h2>
<p>W praktyce procesy mogą być uruchamiane na różnych rdzeniach procesora.</p>
<p><img src="assets/9.svg" /></p>
</section>
<section id="afiniczność-procesora" class="level2">
<h2>Afiniczność procesora</h2>
<p>W Linuksie możemy określić na których procesorach będzie wykonywany proces</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb45-1" title="1">$ <span class="ex">taskset</span> -p 0x11 9726</a></code></pre></div>
<p>Podobne ustawienie istnieje również w menedżerze zadań systemu Windows</p>
<p><img src="assets/affinity.png" /></p>
</section>
</section>
<section id="procesy" class="level1">
<h1>Procesy</h1>
<section id="procesy-w-systemie-linux" class="level2">
<h2>Procesy w systemie Linux</h2>
<p>Procesem nazywamy program, który się wykonuje. W skład procesu wchodzą:</p>
<ul class="incremental">
<li><strong>Stan procesora (rejestry).</strong> Dla <code>x86_64</code> są to:
<ul class="incremental">
<li><code>rbp</code> - wskaźnik początku stosu</li>
<li><code>rsp</code> - wskaźnik końca stosu (ang. Stack pointer)</li>
<li><code>rip</code> - wskaźnik aktualnej instrukcji (ang. Program counter)</li>
<li><code>rflags</code> - rejest flag procesora</li>
<li>rejestry ogólnego przeznaczenia: <code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rbx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>-<code>r15</code></li>
</ul></li>
<li><strong>Pamięć wirtualna</strong> (Tabela stron) (wskazywana przez rejestr <code>CR3</code>)</li>
<li><strong>Deskryptory plików</strong>, czyli (najważniejsze):
<ul class="incremental">
<li>pliki (otwarte za pomocą <code>open()</code>)</li>
<li>gniazda sieciowe (otwarte za pomocą <code>socket()</code>, <code>accept()</code>)</li>
<li>potoki (otwarte za pomocą <code>pipe()</code>)</li>
<li>demultiplexery zdarzeń (otwarte za pomocą <code>epoll_create()</code>)</li>
</ul></li>
<li>Inne struktury danych istotne dla jądra Linux</li>
</ul>
</section>
<section id="podglądanie-procesów-w-systemie" class="level2">
<h2>Podglądanie procesów w systemie</h2>
<p>W systemie Linux, uruchomione procesy możemy zobaczyć za pomocą programu <code>ps</code></p>
<pre class="console"><code>$ ps
  PID TTY           TIME CMD
  896 ttys000    0:00.10 -bash
 1073 ttys001    0:00.08 -bash
 7601 ttys001    0:00.02 bash /Users/hehe/v/e @
 7603 ttys001    1:40.37 nvim
 1074 ttys002    0:00.15 -bash
75444 ttys002    0:00.00 (sleep)
 6110 ttys003    0:00.50 -bash
75450 ttys003    0:00.00 bash /Users/hehe/v/y
 7870 ttys004    0:00.09 -bash
75448 ttys004    0:00.00 sleep 1</code></pre>
<p>Liczba <code>PID</code> to unikalny identyfikator procesu.</p>
</section>
<section id="podglądanie-procesów-w-systemie---top" class="level2">
<h2>Podglądanie procesów w systemie - top</h2>
<p>Programy <code>top</code> oraz <code>htop</code> umożliwają podgląd procesów w czasie rzeczywistym</p>
<pre class="console"><code>$ top
top - 22:20:33 up 56 min,  1 user,  load average: 0,33, 0,52, 0,56
Zadania:razem: 328, działających:   2, śpiących: 326, zatrzymanych:   0, zombie:   0
%CPU:  2,9 uż,  1,8 sy,  0,0 ni, 95,3 be,  0,0 io,  0,0 hi,  0,0 si,  0,0 sk
MiB RAM :  15888,6 razem,   9129,5 wolne,   3037,6 użyte,   3721,6 buf/cache
MiB Swap:   4880,0 razem,   4880,0 wolne,      0,0 użyte.  12497,1 dost. RAM

    PID UŻYTK.    PR  NI    WIRT    REZ    WSP S  %CPU  %PAM     CZAS+ KOMENDA
   1452 hehe       9 -11 2731536  20752  16068 S   8,0   0,1   0:55.86 pulseaudio
   3269 hehe      20   0  522940  55472  40716 R   5,7   0,3   4:34.44 x-terminal-emul
   9773 hehe      20   0  217860  52624  35892 S   4,6   0,3   1:22.04 MainThread
   5321 hehe      20   0 4935640 751040 310720 S   3,4   4,6   4:44.81 firefox
   8058 hehe      20   0  319064  50504  39920 S   2,3   0,3   0:54.45 RDD Process
  34580 hehe      20   0   23400   4224   3288 R   2,3   0,0   0:00.05 top
    287 root      20   0       0      0      0 I   1,1   0,0   0:02.22 kworker/4:1-events
   1903 hehe      20   0 4463536 392068 118248 S   1,1   2,4   1:30.14 gnome-shell
   1989 hehe      20   0  396140   8576   7056 S   1,1   0,1   0:20.24 ibus-daemon
   2286 hehe      20   0 5165376 252416  77816 S   1,1   1,6   0:09.15 dropbox
      1 root      20   0  170040  14056   8280 S   0,0   0,1   0:01.51 systemd</code></pre>
</section>
<section id="podglądanie-procesów-w-systemie---pseudo-system-plików-proc" class="level2">
<h2>Podglądanie procesów w systemie - pseudo system plików /proc</h2>
<pre class="console"><code>$ ls /proc
1   42   129  289  978   1259  1580  2103  8238   34694          kpageflags
2   43   132  290  981   1285  1627  2104  8403   34695          loadavg
3   44   133  291  986   1286  1630  2105  8648   35412          locks
4   46   136  349  990   1301  1762  2106  8808   35848          mdstat
6   47   138  350  994   1358  1780  2107  8827   35849          meminfo
8   48   139  351  1009  1374  1850  2109  8968   35855          misc
9   49   142  353  1011  1377  1870  2110  8970   acpi           modules
10  50   150  437  1013  1378  1875  2118  9421   asound         mounts
11  52   153  438  1015  1379  1881  2192  9773   bootconfig     mtrr
12  53   154  491  1017  1380  1888  2194  10510  buddyinfo      net
13  54   159  519  1019  1381  1903  2247  12703  bus            pagetypeinfo
14  55   194  520  1021  1407  1989  2260  13057  cgroups        partitions
15  56   219  522  1023  1411  1993  2286  13159  cmdline        pressure
16  58   221  524  1025  1412  1994  2376  15059  consoles       schedstat
17  59   242  526  1078  1414  1998  2391  19363  cpuinfo        scsi
18  60   244  528  1079  1421  2004  2513  19374  crypto         self
19  61   245  529  1116  1450  2008  2681  27384  devices        slabinfo
20  62   247  620  1117  1452  2016  3269  27437  diskstats      softirqs</code></pre>
</section>
<section id="drzewo-procesów" class="level2">
<h2>Drzewo procesów</h2>
<p>Drzewo procesów możemy ujrzeć za pomocą programu <code>pstree</code></p>
<pre class="console"><code>$ pstree
systemd─┬─ModemManager───2*[{ModemManager}]
        ├─NetworkManager───2*[{NetworkManager}]
        ├─fwupd───4*[{fwupd}]
        ├─gdm3─┬─gdm-session-wor─┬─gdm-x-session─┬─Xorg───{Xorg}
        │      │                 │               ├─gnome-session-b─┬─ssh-agent
        │      │                 │               │                 └─2*[{gnome-session-b}]
        │      │                 │               └─2*[{gdm-x-session}]
        │      │                 └─2*[{gdm-session-wor}]
        │      └─2*[{gdm3}]
        ├─polkitd───2*[{polkitd}]
        ├─systemd─┬─(sd-pam)
        │         ├─tmux: server─┬─bash───bash───nvim─┬─2*[xclip]
        │         │              │                    └─{nvim}
        │         │              ├─bash───bash───sleep
        │         │              ├─bash
        │         │              └─bash─┬─bash
        │         │                     └─pstree
       ...       ...</code></pre>
</section>
</section>
<section id="tworzenie-procesów" class="level1">
<h1>Tworzenie procesów</h1>
<section id="wywołanie-systemowe---fork" class="level2">
<h2>Wywołanie systemowe - <code>fork()</code></h2>
<p>Do tworzenia procesów, służy wywołanie systemowe <code>fork()</code>. Wywołanie <code>fork()</code> tworzy proces potomny, który jest “klonem” procesu rodzica.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb50-1" title="1">   <span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb50-2" title="2">   {</a>
<a class="sourceLine" id="cb50-3" title="3">       printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb50-4" title="4">--&gt;    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb50-5" title="5">       ...</a>
<a class="sourceLine" id="cb50-6" title="6">   }</a></code></pre></div>
<p>Po wywołaniu <code>fork()</code>:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb51-1" title="1">   <span class="co">/* rodzic */</span>                         <span class="co">/* dziecko */</span></a>
<a class="sourceLine" id="cb51-2" title="2">   <span class="dt">int</span> main(<span class="dt">void</span>)                       <span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb51-3" title="3">   {                                    {</a>
<a class="sourceLine" id="cb51-4" title="4">       printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>);       printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb51-5" title="5">--&gt;    <span class="dt">int</span> pid = fork();             --&gt;    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb51-6" title="6">       ...                                  ...</a>
<a class="sourceLine" id="cb51-7" title="7">   }                                    }</a></code></pre></div>
</section>
<section id="wartość-zwracana-fork" class="level2">
<h2>Wartość zwracana <code>fork()</code></h2>
<p>Wywołanie <code>fork()</code> w procesie potomnym zwraca <code>0</code>, natomiast w procesie rodzica wartością zwróconą będzie PID procesu potomnego.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb52-1" title="1">   <span class="co">/* rodzic */</span>                         <span class="co">/* dziecko */</span></a>
<a class="sourceLine" id="cb52-2" title="2">    <span class="dt">int</span> main(<span class="dt">void</span>)                       <span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb52-3" title="3">    {                                    {</a>
<a class="sourceLine" id="cb52-4" title="4">        printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>);       printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>)j</a>
<a class="sourceLine" id="cb52-5" title="5">        <span class="dt">int</span> pid = fork();                    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb52-6" title="6">        <span class="cf">if</span> (pid == <span class="dv">0</span>)                        <span class="cf">if</span> (pid == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb52-7" title="7">            printf(<span class="st">&quot;child</span><span class="sc">\n</span><span class="st">&quot;</span>);        --&gt;        printf(<span class="st">&quot;child</span><span class="sc">\n</span><span class="st">&quot;</span>);   </a>
<a class="sourceLine" id="cb52-8" title="8">        <span class="cf">else</span>                                 <span class="cf">else</span></a>
<a class="sourceLine" id="cb52-9" title="9"> --&gt;        printf(<span class="st">&quot;parent</span><span class="sc">\n</span><span class="st">&quot;</span>);                  printf(<span class="st">&quot;parent</span><span class="sc">\n</span><span class="st">&quot;</span>);  </a>
<a class="sourceLine" id="cb52-10" title="10">        <span class="cf">return</span> <span class="dv">0</span>;                            <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb52-11" title="11">    }                                    }</a></code></pre></div>
<p>Na podstawie wartości zwracanej, możemy określić czy “znajdujemy” się w procesie potomnym czy w procesie rodzica.</p>
</section>
<section id="oczekiwanie-na-zakończenie-procesu-potomnego" class="level2">
<h2>Oczekiwanie na zakończenie procesu potomnego</h2>
<p>Do oczekiwania na zakończenie procesu potomnego służy, wywołanie systemowe <code>wait()</code>, które blokuje program do momentu zakończenia dowolnego procesu potomnego.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb53-1" title="1">   <span class="co">/* rodzic */</span>                         <span class="co">/* dziecko */</span></a>
<a class="sourceLine" id="cb53-2" title="2">    <span class="dt">int</span> main(<span class="dt">void</span>)                       <span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb53-3" title="3">    {                                    {</a>
<a class="sourceLine" id="cb53-4" title="4">        printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>);       printf(<span class="st">&quot;przed utworzeniem</span><span class="sc">\n</span><span class="st">&quot;</span>)j</a>
<a class="sourceLine" id="cb53-5" title="5">        <span class="dt">int</span> pid = fork();                    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb53-6" title="6">        <span class="cf">if</span> (pid == <span class="dv">0</span>) {                      <span class="cf">if</span> (pid == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb53-7" title="7">            printf(<span class="st">&quot;child</span><span class="sc">\n</span><span class="st">&quot;</span>);                   printf(<span class="st">&quot;child</span><span class="sc">\n</span><span class="st">&quot;</span>);   </a>
<a class="sourceLine" id="cb53-8" title="8">        } <span class="cf">else</span> {                             } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb53-9" title="9">            printf(<span class="st">&quot;parent</span><span class="sc">\n</span><span class="st">&quot;</span>);                  printf(<span class="st">&quot;parent</span><span class="sc">\n</span><span class="st">&quot;</span>);  </a>
<a class="sourceLine" id="cb53-10" title="10"> --&gt;        wait(NULL);                          wait(NULL);</a>
<a class="sourceLine" id="cb53-11" title="11">        }                                    }</a>
<a class="sourceLine" id="cb53-12" title="12">        <span class="cf">return</span> <span class="dv">0</span>;                     --&gt;    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb53-13" title="13">    }                                    }</a></code></pre></div>
</section>
<section id="wait-obsługa-błędów" class="level2">
<h2><code>wait()</code> obsługa błędów</h2>
<p>Wywołanie systemowe <code>wait()</code> zwraca <code>pid</code> zakończonego procesu. Jeżeli wartość jest ujemna to wystąpił błąd. Błąd uzyskać można odczytująć zmienną <code>errno</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb54-1" title="1">pid = wait(NULL);</a>
<a class="sourceLine" id="cb54-2" title="2"><span class="cf">if</span> (pid &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb54-3" title="3">    fprintf(stderr, <span class="st">&quot;error: wait: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror(errno));</a>
<a class="sourceLine" id="cb54-4" title="4">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb54-5" title="5">}</a></code></pre></div>
</section>
<section id="wait-odczytanie-wartości-zwracanej" class="level2">
<h2><code>wait()</code> odczytanie wartości zwracanej</h2>
<p>Można odczytać wartość jaką zwrócił proces potomny przekazując wskaźnik jako pierwszy argument wywołania <code>wait()</code>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb55-1" title="1"><span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb55-2" title="2">pid = wait(&amp;status);</a>
<a class="sourceLine" id="cb55-3" title="3"><span class="cf">if</span> (pid &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb55-4" title="4">    fprintf(stderr, <span class="st">&quot;error: wait: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror(errno));</a>
<a class="sourceLine" id="cb55-5" title="5">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb55-6" title="6">}</a>
<a class="sourceLine" id="cb55-7" title="7"><span class="cf">if</span> (WIFEXITED(status))</a>
<a class="sourceLine" id="cb55-8" title="8">    printf(<span class="st">&quot;dziecko zwróciło: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, WEXITSTATUS(status));</a></code></pre></div>
</section>
<section id="oczekiwanie-na-zakończenie-kilku-procesów-potomnych" class="level2">
<h2>Oczekiwanie na zakończenie kilku procesów potomnych</h2>
<p>Wywołanie systemowe <code>wait()</code> czeka na pierwszy proces potomny, który ulegnie zakończeniu. Jeżeli utworzonych zostało więcej procesów potomnych, to należy ponowić oczekiwanie.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb56-1" title="1"><span class="cf">while</span> (true) {</a>
<a class="sourceLine" id="cb56-2" title="2">    <span class="dt">int</span> pid = wait(NULL);</a>
<a class="sourceLine" id="cb56-3" title="3">    <span class="cf">if</span> (pid &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb56-4" title="4">        <span class="co">/* Nie ma już dzieci */</span></a>
<a class="sourceLine" id="cb56-5" title="5">        <span class="cf">if</span> (errno == ECHILD)</a>
<a class="sourceLine" id="cb56-6" title="6">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb56-7" title="7">        <span class="co">/* Wystąpił rzeczywisty błąd */</span></a>
<a class="sourceLine" id="cb56-8" title="8">        fprintf(stderr, <span class="st">&quot;error: wait: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror(errno));</a>
<a class="sourceLine" id="cb56-9" title="9">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb56-10" title="10">    }</a>
<a class="sourceLine" id="cb56-11" title="11">}</a></code></pre></div>
</section>
<section id="wywołanie-waitpid" class="level2">
<h2>Wywołanie <code>waitpid()</code></h2>
<p>Wywołanie systemowe <code>waitpid()</code> pozwala zaczekać na konkretny process potomny</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb57-1" title="1"><span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb57-2" title="2">waitpid(pid, &amp;status, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb57-3" title="3"><span class="cf">if</span> (WIFEXITED(status))</a>
<a class="sourceLine" id="cb57-4" title="4">    printf(<span class="st">&quot;dziecko zwróciło: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, WEXITSTATUS(status));</a></code></pre></div>
<p>Tak naprawde <code>wait()</code> działa tak samo jak:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb58-1" title="1"><span class="dt">int</span> pid = waitpid(-<span class="dv">1</span>, &amp;status, <span class="dv">0</span>);</a></code></pre></div>
<p>Więcej informacji</p>
<pre class="console"><code>$ man 2 wait</code></pre>
</section>
<section id="najistotniejsze-efekty-fork" class="level2">
<h2>Najistotniejsze efekty <code>fork()</code></h2>
<p>Podczas <strong>wywołania systemowego</strong> <code>fork()</code>:</p>
<ul class="incremental">
<li>Używany jest ten dalej ten sam <strong>kod programu</strong></li>
<li>Kopiowany jest <strong>stan procesora</strong> (w tym <strong>wskaźnik aktualnej instrukcji</strong>)</li>
<li>Dziedziczone są <strong>deskryptory plików</strong>:</li>
<li>Kopiowana są <strong>strony pamięci</strong>, ale dopiero po pierwszym zapisie (<strong>Copy-on-write</strong>)</li>
</ul>
</section>
<section id="tworzenie-procesu-który-będzie-wykonywał-inny-program" class="level2">
<h2>Tworzenie procesu, który będzie wykonywał inny program</h2>
<p>Wywołanie <code>fork()</code> powoduje utworzenie nowego procesu, który jest niemalże dokładną kopią procesu potomnego. Żeby zmienić kod wykonywanego programu należy użyc funkcji z rodziny <code>exec()</code></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb60-1" title="1"><span class="dt">int</span> execl(<span class="dt">const</span> <span class="dt">char</span> *path,</a>
<a class="sourceLine" id="cb60-2" title="2">          <span class="dt">const</span> <span class="dt">char</span> *arg0, ..., <span class="co">/*, (char *)0, */</span>);</a>
<a class="sourceLine" id="cb60-3" title="3"><span class="dt">int</span> execle(<span class="dt">const</span> <span class="dt">char</span> *path,</a>
<a class="sourceLine" id="cb60-4" title="4">           <span class="dt">const</span> <span class="dt">char</span> *arg0, ..., <span class="co">/* (char *)0 char *const envp[] */</span>);</a>
<a class="sourceLine" id="cb60-5" title="5"><span class="dt">int</span> execlp(<span class="dt">const</span> <span class="dt">char</span> *file,</a>
<a class="sourceLine" id="cb60-6" title="6">           <span class="dt">const</span> <span class="dt">char</span> *arg0, ..., <span class="co">/*, (char *)0, */</span>);</a>
<a class="sourceLine" id="cb60-7" title="7"><span class="dt">int</span> execv(<span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">char</span> *<span class="dt">const</span> argv[]);</a>
<a class="sourceLine" id="cb60-8" title="8"><span class="dt">int</span> execvp(<span class="dt">const</span> <span class="dt">char</span> *file, <span class="dt">char</span> *<span class="dt">const</span> argv[]);</a>
<a class="sourceLine" id="cb60-9" title="9"><span class="dt">int</span> execvP(<span class="dt">const</span> <span class="dt">char</span> *file, <span class="dt">const</span> <span class="dt">char</span> *search_path,</a>
<a class="sourceLine" id="cb60-10" title="10">          kchar *<span class="dt">const</span> argv[]);</a></code></pre></div>
<p>Wywołanie systemowe <code>exec()</code> ładuje nowy program do aktualnego procesu (czyli podmienia sekcje .data, .bss, .text, stos i sterte, biblioteki współdzielone)</p>
</section>
<section id="przykład-wykorzystania-exec" class="level2">
<h2>Przykład wykorzystania <code>exec()</code></h2>
<p>Przykładowy program, który utworzy proces potomny i załaduje do niego program <code>ls</code>. Proces rodzica będzie czekał na zakończenie procesu potomnego.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)</a>
<a class="sourceLine" id="cb61-2" title="2">{</a>
<a class="sourceLine" id="cb61-3" title="3">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb61-4" title="4">    ret = fork();</a>
<a class="sourceLine" id="cb61-5" title="5">    <span class="cf">if</span> (ret == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb61-6" title="6">        <span class="dt">char</span> *argv[] = { <span class="st">&quot;ls&quot;</span>, NULL };</a>
<a class="sourceLine" id="cb61-7" title="7">        ret = execvp(<span class="st">&quot;ls&quot;</span>, argv);</a>
<a class="sourceLine" id="cb61-8" title="8">        <span class="cf">if</span> (ret) {</a>
<a class="sourceLine" id="cb61-9" title="9">            perror(<span class="st">&quot;execvp: &quot;</span>);</a>
<a class="sourceLine" id="cb61-10" title="10">            <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb61-11" title="11">        }</a>
<a class="sourceLine" id="cb61-12" title="12">    }</a>
<a class="sourceLine" id="cb61-13" title="13"></a>
<a class="sourceLine" id="cb61-14" title="14">    wait(NULL);</a>
<a class="sourceLine" id="cb61-15" title="15"></a>
<a class="sourceLine" id="cb61-16" title="16">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-17" title="17">}</a></code></pre></div>
</section>
<section id="procesy-zombie" class="level2">
<h2>Procesy zombie</h2>
<p>Jeżeli proces zakończył swoje wykonywanie, a rodzic nie wykonał <code>wait()</code> to będzie on nadal widoczny na liście procesów, do momentu wykonania <code>wait()</code> przez rodzica.</p>
<p>Poniższy kod tworzy proces zombie, który będzie istniał około 30 sekund:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb62-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb62-2" title="2"></a>
<a class="sourceLine" id="cb62-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb62-4" title="4">{</a>
<a class="sourceLine" id="cb62-5" title="5">    <span class="co">/* Klonujemy proces */</span></a>
<a class="sourceLine" id="cb62-6" title="6">    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb62-7" title="7">    <span class="co">/* Jeżeli jesteśmy dzieckiem */</span></a>
<a class="sourceLine" id="cb62-8" title="8">    <span class="cf">if</span> (pid == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb62-9" title="9">        <span class="cf">return</span> <span class="dv">0</span>; <span class="co">/* Kończymy - proces jest zombie do wykonania wait() */</span></a>
<a class="sourceLine" id="cb62-10" title="10">    <span class="co">/* Jeżeli jesteśmy rodzicem to czekamy 30 sekund*/</span></a>
<a class="sourceLine" id="cb62-11" title="11">    sleep(<span class="dv">30</span>);</a>
<a class="sourceLine" id="cb62-12" title="12">    <span class="co">/* Odczytujemy kod wyjścia procesu i usuwamy go z listy procesów */</span></a>
<a class="sourceLine" id="cb62-13" title="13">    wait(NULL);</a>
<a class="sourceLine" id="cb62-14" title="14">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb62-15" title="15">}</a></code></pre></div>
</section>
<section id="pytanie" class="level2">
<h2>Pytanie</h2>
<p>Jeżeli nie wywołamy <code>wait()</code>, to dlaczego dziecko znika po zakończeniu rodzica?</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb63-2" title="2"></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb63-4" title="4">{</a>
<a class="sourceLine" id="cb63-5" title="5">    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb63-6" title="6">    <span class="cf">if</span> (pid == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb63-7" title="7">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb63-8" title="8"></a>
<a class="sourceLine" id="cb63-9" title="9">    <span class="co">/* Nie wywołujemy tutaj wywołania systemowego wait(), więc nie zakończymy</span></a>
<a class="sourceLine" id="cb63-10" title="10"><span class="co">       dziecka */</span></a>
<a class="sourceLine" id="cb63-11" title="11"></a>
<a class="sourceLine" id="cb63-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb63-13" title="13">}</a></code></pre></div>
</section>
<section id="odpowiedź" class="level2">
<h2>Odpowiedź</h2>
<p>Każdy osierocony proces jest adoptowany przez główny proces (<code>systemd</code> albo <code>init</code>).</p>
<pre class="console"><code>$ pstree
systemd─┬─ModemManager─── ...
        ├─NetworkManager─── ...
        ├─fwupd───4*[{fwupd}]
        ├─gdm3─┬─gdm-session-wor─┬─gdm-x-session─┬─Xorg───{Xorg}
        │      │                 │               ├─gnome-session-b─┬─ssh-agent
        │      │                 │               │                 └─2*[{gnome-session-b}]
        │      │                 │               └─2*[{gdm-x-session}]
        │      │                 └─2*[{gdm-session-wor}]
        │      └─2*[{gdm3}]
        ├─ X
       ... ^
           |
           &#39;---- tu zostanie zaadoptowany osierocony proces</code></pre>
<p>Następnie <code>systemd</code> lub <code>init</code> wywoła na nim <code>wait()</code>.</p>
</section>
<section id="zagadka-0" class="level2">
<h2>Zagadka 0</h2>
<p>Ile procesów zostanie utworzonych w poniższym programie?</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb65-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb65-2" title="2"></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb65-4" title="4">{</a>
<a class="sourceLine" id="cb65-5" title="5">    fork();</a>
<a class="sourceLine" id="cb65-6" title="6">    fork();</a>
<a class="sourceLine" id="cb65-7" title="7">    fork();</a>
<a class="sourceLine" id="cb65-8" title="8"></a>
<a class="sourceLine" id="cb65-9" title="9">    fork();</a>
<a class="sourceLine" id="cb65-10" title="10">    fork();</a>
<a class="sourceLine" id="cb65-11" title="11">    fork();</a>
<a class="sourceLine" id="cb65-12" title="12"></a>
<a class="sourceLine" id="cb65-13" title="13">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb65-14" title="14">}</a></code></pre></div>
</section>
<section id="zagadka-1" class="level2">
<h2>Zagadka 1</h2>
<p>Ile procesów zostanie utworzonych w poniższym programie?</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb66-2" title="2"></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb66-4" title="4">{</a>
<a class="sourceLine" id="cb66-5" title="5">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; ++i)</a>
<a class="sourceLine" id="cb66-6" title="6">        fork();</a>
<a class="sourceLine" id="cb66-7" title="7"></a>
<a class="sourceLine" id="cb66-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb66-9" title="9">}</a></code></pre></div>
</section>
<section id="zagadka-2" class="level2">
<h2>Zagadka 2</h2>
<p>Ile procesów zostanie utworzonych w poniższym programie?</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb67-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb67-2" title="2"></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb67-4" title="4">{</a>
<a class="sourceLine" id="cb67-5" title="5">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; ++i) {</a>
<a class="sourceLine" id="cb67-6" title="6">        fork();</a>
<a class="sourceLine" id="cb67-7" title="7">        execlp(<span class="st">&quot;ls&quot;</span>, <span class="st">&quot;ls&quot;</span>, NULL);</a>
<a class="sourceLine" id="cb67-8" title="8">    }</a>
<a class="sourceLine" id="cb67-9" title="9"></a>
<a class="sourceLine" id="cb67-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb67-11" title="11">}</a></code></pre></div>
</section>
</section>
<section id="planista" class="level1">
<h1>Planista</h1>
<section id="planista-w-systemie-linux" class="level2">
<h2>Planista w systemie Linux</h2>
<p>Decydowaniem, który proces zostanie uruchomiony jako następny zajmuje się planista (ang. scheduler).</p>
<p>Zadaniem planisty jest dbanie o podział czasu procesora według ustalonych celów.</p>
<p>Planista w systemie Linux to <strong>Całkowicie Sprawiedliwy Planista</strong> (ang. Completely Fair Scheduler, CFS)</p>
<p>Dba on o to aby każdy proces otrzymał sprawiedliwą część czasu procesora.</p>
<p>Za każdym razem uruchamia ten process który otrzymał do tej pory najmniej czasu, w stosunku do należnej części.</p>
</section>
<section id="jak-planista-reprezentuje-procesy" class="level2">
<h2>Jak planista reprezentuje procesy</h2>
<p>W systemie Linux każdy proces, jest reprezentowany przez strukturę <code>struct task_struct</code></p>
<p>Oto jej ważniejsze pola:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb68-1" title="1"><span class="kw">struct</span> task_struct {</a>
<a class="sourceLine" id="cb68-2" title="2">    <span class="kw">struct</span> list_head tasks           <span class="co">/* Wpis na liscie procesów */</span></a>
<a class="sourceLine" id="cb68-3" title="3">    pid_t pid;                       <span class="co">/* Identyfikator procesu */</span></a>
<a class="sourceLine" id="cb68-4" title="4">    <span class="kw">struct</span> mm_struct *mm             <span class="co">/* Przestrzeń adresowa */</span></a>
<a class="sourceLine" id="cb68-5" title="5">    <span class="kw">struct</span> task_struct *real_parent; <span class="co">/* Prawdziwy rodzic - ten kto wywołał clone() */</span></a>
<a class="sourceLine" id="cb68-6" title="6">    <span class="kw">struct</span> task_struct *parent;      <span class="co">/* Odbiorca SIGCHLD i wait4() */</span></a>
<a class="sourceLine" id="cb68-7" title="7">    <span class="kw">struct</span> list_head children;       <span class="co">/* Dzieci procesu */</span></a>
<a class="sourceLine" id="cb68-8" title="8">    <span class="kw">struct</span> sigpending pending;       <span class="co">/* Lista oczekujących sygnałów */</span></a>
<a class="sourceLine" id="cb68-9" title="9">    <span class="kw">struct</span> files_struct *files;      <span class="co">/* Otwarte deskryptory plików */</span></a>
<a class="sourceLine" id="cb68-10" title="10">    <span class="dt">void</span> *stack                      <span class="co">/* Wskaznik do stosu jądra dla tego</span></a>
<a class="sourceLine" id="cb68-11" title="11"><span class="co">                                        procesu - tu są zapisane rejestry */</span></a>
<a class="sourceLine" id="cb68-12" title="12">    ...</a>
<a class="sourceLine" id="cb68-13" title="13">};</a></code></pre></div>
</section>
<section id="lista-procesów" class="level2">
<h2>Lista procesów</h2>
<p>System operacyjny przechowuje procesy na liście dwukierunkowej.</p>
<p><img src="assets/12.svg" /></p>
</section>
<section id="jak-cfs-przydziela-czas-procesora" class="level2">
<h2>Jak CFS przydziela czas procesora</h2>
<p>Długości odcinków czasowych są wyliczane dynamicznie, na podstawie docelowego opóźnienia (ang. target latency) i priorytetu procesu (niceness i priority), dzięki czemu podział czasu procesora jest zawsze sprawiedliwy.</p>
<p><img src="assets/10.svg" /></p>
</section>
<section id="preemptive-vs-cooperative-multitasking" class="level2">
<h2>Preemptive vs Cooperative multitasking</h2>
<p>W przypadku preemptive multitasking planista może wywłaszczyć proces w dowolnym momencie, w przypadku cooperative - tylko w wyznaczonym przez proces momencie. <strong>Planista w Linuksie implementuje preemptive multitasking.</strong></p>
<p><img src="assets/11.svg" /></p>
</section>
<section id="kiedy-następuje-wywłaszczenie" class="level2">
<h2>Kiedy następuje wywłaszczenie</h2>
<p>CFS może zaplanować wykonywanie innego procesu w momencie wystąpienia przerwania:</p>
<p>Czyli na przykład w momencie:</p>
<ul class="incremental">
<li>naciśnięcia klawisza, odebrania pakietu sieciowego czy innego zdarzenia sprzętowego;</li>
<li>przerwania pochodzącego od czasomierza systemowego (Programmable System Timer);</li>
<li>wywołania systemowego (np. <code>open()</code>, <code>fork()</code>, <code>sleep()</code>, <code>write()</code>).</li>
</ul>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb69-1" title="1"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb69-2" title="2">{</a>
<a class="sourceLine" id="cb69-3" title="3">    <span class="dt">int</span> x, w;</a>
<a class="sourceLine" id="cb69-4" title="4">    x = <span class="dv">1</span>;                               &lt;---- tu może wystąpić przerwanie, możliwa zmiana procesu</a>
<a class="sourceLine" id="cb69-5" title="5">    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, x);                   &lt;---- wywołanie systemowe write(), możliwa zmiana procesu</a>
<a class="sourceLine" id="cb69-6" title="6">    <span class="dt">int</span> fd = open(<span class="st">&quot;plik.txt&quot;</span>, O_RDONLY); &lt;---- wywołanie systemowe open(), możliwa zmiana procesu</a>
<a class="sourceLine" id="cb69-7" title="7">    w = x + <span class="dv">1</span>;                           &lt;---- tu może wystąpić przerwanie, możliwa zmiana procesu</a>
<a class="sourceLine" id="cb69-8" title="8">    <span class="dt">int</span> *g = malloc(<span class="kw">sizeof</span>(*g));         &lt;---- malloc() nie jest wywołaniem systemowym ale</a>
<a class="sourceLine" id="cb69-9" title="9">                                               może wywołać brk(), sbrk(), mmap(), które są,</a>
<a class="sourceLine" id="cb69-10" title="10">                                               czyli możliwa zmiana procesu</a>
<a class="sourceLine" id="cb69-11" title="11">}</a></code></pre></div>
</section>
</section>
<section id="wywołania-systemowe" class="level1">
<h1>Wywołania systemowe</h1>
<section id="co-jest-efektem-kompilacji" class="level2">
<h2>Co jest efektem kompilacji?</h2>
<p>Kod w języku C jest kompilowany do instrukcji maszynowych</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1"><span class="dt">int</span> foo(<span class="dt">int</span> a, <span class="dt">int</span> b)  _foo: </a>
<a class="sourceLine" id="cb70-2" title="2">{                      pushq %rbp            <span class="co">// Zapisz podstawe stosu</span></a>
<a class="sourceLine" id="cb70-3" title="3">    <span class="dt">int</span> c = a + b;     movq  %rsp, %rbp      <span class="co">// Weź szczyt stosu jako podstawę</span></a>
<a class="sourceLine" id="cb70-4" title="4">    <span class="cf">return</span> c;          movl  %edi, %eax      <span class="co">// Wrzuć pierwszy argument do %eax</span></a>
<a class="sourceLine" id="cb70-5" title="5">}                      addl  %esi, %eax      <span class="co">// Dodaj drugi argument do %eax</span></a>
<a class="sourceLine" id="cb70-6" title="6">                       movl  %eax, -<span class="dv">4</span>(%rbp)  <span class="co">// Wynik wrzuć na stos</span></a>
<a class="sourceLine" id="cb70-7" title="7">                       movl  -<span class="dv">4</span>(%rbp), %eax  <span class="co">// Przekaż wartość zwracaną przez %eax</span></a>
<a class="sourceLine" id="cb70-8" title="8">                       popq  %rbp            <span class="co">// Załaduj zapisaną podstawę stosu podstawę stosu</span></a>
<a class="sourceLine" id="cb70-9" title="9">                       retq                  <span class="co">// Wróć z powrotem w miejsce wywołania  </span></a></code></pre></div>
</section>
<section id="instrukcje-uprzywilejowane" class="level2">
<h2>Instrukcje uprzywilejowane</h2>
<p>Nie wszystkie instrukcje procesora są dostępne dla procesów użytkownika. Procesy użytkownika nie mogą między innymi odczytywać pamięci chronionej, ani wykonywać niektórych instrukcji. Na przykład:</p>
<ul class="incremental">
<li><code>LGDT</code> - nadpisywanie tablicy przerwań;</li>
<li><code>IN</code>, <code>OUT</code> - obługa urządzeń wejścia/wyjścia;</li>
<li><code>MOV %eax, %cr3</code> - modyfikacja tablicy stron.</li>
</ul>
<p>Procesy mogą jedynie “prosić” system operacyjny, żeby on w ich imieniu wykonywał te instrukcje. Tą prośbą są <strong>wywołania systemowe</strong>.</p>
</section>
<section id="wywołania-systemowe-1" class="level2">
<h2>Wywołania systemowe</h2>
<p>Wywołania systemowe, są przerwaniem programowym (ang. software interrupt)</p>
<ol class="incremental" type="1">
<li>Program wykonuje przerwanie (<code>syscall</code> lub <code>int 0x80</code>), w rejestrach ustawia odpowieni numer przerwania oraz przekazuje odpowiednie argumenty</li>
<li>System operacyjny zaczyna wykonywać procedurę obsługi tego przerwania: zapisuje stan procesora, przełącza stos programu na stos jądra (zmienia rejestr <code>%esp</code> - wskaźnik stosu), i wykonuje odpowiednią operację wskazaną numerem wywołania systemowego.</li>
<li>Po wykonaniu wywołania systemowego system operacyjny przywraca stan procesora (w tym stos procesu) i wznawiane jest wykonywanie programu.</li>
</ol>
<div class="sourceCode" id="cb71"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb71-1" title="1"><span class="fu">message:</span></a>
<a class="sourceLine" id="cb71-2" title="2">    .asciz <span class="st">&quot;Hello world\n&quot;</span></a>
<a class="sourceLine" id="cb71-3" title="3">.set message_size, . - message</a>
<a class="sourceLine" id="cb71-4" title="4">...</a>
<a class="sourceLine" id="cb71-5" title="5">movl<span class="bn"> $1, </span>%<span class="kw">edi</span></a>
<a class="sourceLine" id="cb71-6" title="6">leaq message(%rip), %<span class="kw">rsi</span></a>
<a class="sourceLine" id="cb71-7" title="7"><span class="bu">movq</span> <span class="dv">$</span>message_size, %<span class="kw">rdx</span></a>
<a class="sourceLine" id="cb71-8" title="8"><span class="bu">movq</span><span class="bn"> $1, </span>%<span class="kw">rax</span>             <span class="co">;1 is sys_write syscall number</span></a>
<a class="sourceLine" id="cb71-9" title="9"><span class="bu">syscall</span></a></code></pre></div>
</section>
<section id="wywołania-systemowe-a-funkcje" class="level2">
<h2>Wywołania systemowe a funkcje</h2>
<p>Biblioteka standardowa języka C (np. <code>glibc</code>, <code>musl</code> lub <code>uClibc</code>), implementuje funkcje, które uruchamiają wywołania systemowe o podobnych nazwach. Oprócz tego implementuje jeszcze dodatkową funkcjonalność oraz funkcje, które nie są wywołaniami systemowymi.</p>
<p>Przykłady:</p>
<table>
<thead>
<tr class="header">
<th>funkcja</th>
<th>typ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>open()</code></td>
<td><code>syscall(SYS_open, ...)</code></td>
</tr>
<tr class="even">
<td><code>fork()</code></td>
<td><code>syscall(SYS_fork, ...)</code></td>
</tr>
<tr class="odd">
<td><code>write()</code></td>
<td><code>syscall(SYS_write, ...)</code></td>
</tr>
<tr class="even">
<td><code>read()</code></td>
<td><code>syscall(SYS_read, ...)</code></td>
</tr>
<tr class="odd">
<td><code>printf()</code></td>
<td><code>syscall(SYS_write)</code> + dodatkowa funkcjonalność</td>
</tr>
<tr class="even">
<td><code>malloc()</code></td>
<td><code>syscall(SYS_brk)</code> + dodatkowa funkcjonalność</td>
</tr>
<tr class="odd">
<td><code>fopen()</code></td>
<td><code>syscall(SYS_open)</code> + dodatkowa funkcjonalność</td>
</tr>
<tr class="even">
<td><code>strlen()</code></td>
<td>funkcja biblioteczna</td>
</tr>
<tr class="odd">
<td><code>memcpy()</code></td>
<td>funkcja biblioteczna</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pamięć-procesu" class="level1">
<h1>Pamięć procesu</h1>
<section id="zmienne-reprezentują-komórki-pamięci" class="level2">
<h2>Zmienne reprezentują komórki pamięci</h2>
<p>Każda zmienna reprezentuje pewną komórkę pamięci.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb72-1" title="1"><span class="dt">int</span> y = <span class="dv">2</span>; <span class="co">/* Zmienna w sekcji .data */</span></a>
<a class="sourceLine" id="cb72-2" title="2"></a>
<a class="sourceLine" id="cb72-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb72-4" title="4">{</a>
<a class="sourceLine" id="cb72-5" title="5">    <span class="dt">int</span> x; <span class="co">/* Zmienna na stosie */</span></a>
<a class="sourceLine" id="cb72-6" title="6"></a>
<a class="sourceLine" id="cb72-7" title="7">    printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, &amp;x);</a>
<a class="sourceLine" id="cb72-8" title="8">    printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, &amp;y);</a>
<a class="sourceLine" id="cb72-9" title="9"></a>
<a class="sourceLine" id="cb72-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb72-11" title="11">}</a></code></pre></div>
</section>
<section id="pamięć-wirtualna" class="level2">
<h2>Pamięć wirtualna</h2>
<p>Proces operuje na wirtualnych adresach pamięci, które są mapowane do fizycznych adresów, przez tabele stron. Instruuje ona jednostkę zarządzania pamięcią (ang. Memory Management Unit) w jaki sposób ma mapować pamięć.</p>
<p><img src="assets/1.svg" /></p>
</section>
<section id="sekcje-pamięci" class="level2">
<h2>Sekcje pamięci</h2>
<p>W systemie Linux skompilowany program będzie miał odpowiednią strukturę w pamięci:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb73-1" title="1"><span class="dt">int</span> x;  <span class="co">/* Niezainicjalizowane dane (.bss) */</span></a>
<a class="sourceLine" id="cb73-2" title="2"><span class="dt">int</span> y = <span class="dv">3</span>; <span class="co">/* Zainicjalizowane dane (.data) */</span></a>
<a class="sourceLine" id="cb73-3" title="3"><span class="dt">void</span> foo(<span class="dt">int</span> x) <span class="co">/* Argumenty w rejestrach lub na stosie */</span>     ---.</a>
<a class="sourceLine" id="cb73-4" title="4">{                                                                 |</a>
<a class="sourceLine" id="cb73-5" title="5">    <span class="dt">static</span> <span class="dt">int</span> x; <span class="co">/* Niezainicjalizowane dane (.bss) */</span>           |</a>
<a class="sourceLine" id="cb73-6" title="6">    <span class="dt">static</span> <span class="dt">int</span> y = <span class="dv">4</span>; <span class="co">/* Zainicjalizowane dane (.data) */</span>         |</a>
<a class="sourceLine" id="cb73-7" title="7">}                                                                 |</a>
<a class="sourceLine" id="cb73-8" title="8"><span class="dt">int</span> main(<span class="dt">void</span>)                                                    |    kod</a>
<a class="sourceLine" id="cb73-9" title="9">{                                                                 |___ programu</a>
<a class="sourceLine" id="cb73-10" title="10">    <span class="dt">int</span> x; <span class="co">/* Alokacja na stosie */</span>                               |    umieszczany</a>
<a class="sourceLine" id="cb73-11" title="11">    <span class="dt">int</span> *y = malloc(<span class="dv">1024</span>); <span class="co">/* Wskaźnik na stosie, */</span>              |    w sekcji .text</a>
<a class="sourceLine" id="cb73-12" title="12">                           <span class="co">/* a blok pamięci na stercie */</span>        |</a>
<a class="sourceLine" id="cb73-13" title="13">    foo(<span class="dv">1</span>); <span class="co">/* Adres powrotu na stosie,                           |</span></a>
<a class="sourceLine" id="cb73-14" title="14"><span class="co">               argumenty w rejestrach lub na stosie  */</span>           |</a>
<a class="sourceLine" id="cb73-15" title="15">    <span class="cf">return</span> <span class="dv">0</span>;                                                     |</a>
<a class="sourceLine" id="cb73-16" title="16">}                                                              ---&#39;</a></code></pre></div>
</section>
<section id="sekcje-pamięci-procesu" class="level2">
<h2>Sekcje pamięci procesu</h2>
<p>Pamięć procesu podzielona jest na sekcje, w których znajdują się “podobnego” rodzaju dane.</p>
<p><img src="assets/2.svg" /></p>
</section>
<section id="przykład-sekcji-pamięci---proces-yes" class="level2">
<h2>Przykład sekcji pamięci - proces <code>yes</code></h2>
<pre class="console"><code>$ cat /proc/39299/maps
56148e969000-56148e96b000 r--p 00000000 08:05 24118661   /usr/bin/yes
56148e96b000-56148e96f000 r-xp 00002000 08:05 24118661   /usr/bin/yes
56148e96f000-56148e971000 r--p 00006000 08:05 24118661   /usr/bin/yes
56148e972000-56148e973000 r--p 00008000 08:05 24118661   /usr/bin/yes
56148e973000-56148e974000 rw-p 00009000 08:05 24118661   /usr/bin/yes
56148f694000-56148f6b5000 rw-p 00000000 00:00 0          [heap]
7f9f89876000-7f9f8a8cc000 r--p 00000000 08:05 24117276   /usr/lib/locale/locale-archive
7f9f8a8cc000-7f9f8a8ee000 r--p 00000000 08:05 24122481   /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f9f8a8ee000-7f9f8aa66000 r-xp 00022000 08:05 24122481   /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f9f8aa66000-7f9f8aab4000 r--p 0019a000 08:05 24122481   /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f9f8aab4000-7f9f8aab8000 r--p 001e7000 08:05 24122481   /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f9f8aab8000-7f9f8aaba000 rw-p 001eb000 08:05 24122481   /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f9f8aaba000-7f9f8aac0000 rw-p 00000000 00:00 0
7f9f8aae0000-7f9f8aae1000 r--p 00000000 08:05 24122477   /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f9f8aae1000-7f9f8ab04000 r-xp 00001000 08:05 24122477   /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f9f8ab04000-7f9f8ab0c000 r--p 00024000 08:05 24122477   /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f9f8ab0d000-7f9f8ab0e000 r--p 0002c000 08:05 24122477   /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f9f8ab0e000-7f9f8ab0f000 rw-p 0002d000 08:05 24122477   /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f9f8ab0f000-7f9f8ab10000 rw-p 00000000 00:00 0
7ffe6a478000-7ffe6a499000 rw-p 00000000 00:00 0          [stack]
7ffe6a5cb000-7ffe6a5cf000 r--p 00000000 00:00 0          [vvar]
7ffe6a5cf000-7ffe6a5d1000 r-xp 00000000 00:00 0          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0  [vsyscall]</code></pre>
</section>
<section id="address-space-layout-randomization" class="level2">
<h2>Address space layout randomization</h2>
<p>Adresy sekcji są losowe, aby utrudnić manipulacje na pamięci atakującemu.</p>
<p><img src="assets/3.svg" /></p>
</section>
<section id="kaslr" class="level2">
<h2>KASLR</h2>
<p>Jądro jest mapowane pod losowym adresem</p>
<p><img src="assets/4.svg" /></p>
</section>
<section id="kaiser" class="level2">
<h2>KAISER</h2>
<p>Mapowana jest tylko niezbędna część jądra. Po przełączeniu się w tryb jądra (przy wywołaniach systemowych) tabela stron jest przełączana na pełną wersję (zmiana rejestru CR3).</p>
<p><img src="assets/5.svg" /></p>
</section>
<section id="copy-on-write" class="level2">
<h2>Copy-on-write</h2>
<p>Strony pamięci wirtualnej nowego procesu oznaczone są jako tylko do odczytu. Próba nadpisania skutkuje wyjątkiem Page Fault, którego obsługa pozwala systemowi operacyjnemu skopiować stronę</p>
<p><img src="assets/0.svg" /></p>
</section>
</section>
<section id="dziękuję-za-uwagę" class="level1">
<h1>Dziękuję za uwagę</h1>
<section id="dalsza-lektura" class="level2">
<h2>Dalsza lektura</h2>
<ul class="incremental">
<li><strong>Książki</strong>
<ul class="incremental">
<li>Love Robert. 2010. Linux Kernel Development. Pearson Education.</li>
<li>Love Robert. 2013. Linux System Programming. O’REILLY.</li>
<li>Stevens Richard W., Rago Stephen A., Advanced Programming in the UNIX® Environment, Third Edition. Addison-Wesley.</li>
</ul></li>
<li><strong>Artykuły</strong>
<ul class="incremental">
<li>https://lwn.net/Articles/738975/</li>
<li>https://samwho.dev/blog/context-switching-on-x86/</li>
</ul></li>
<li><strong>Manual</strong>
<ul class="incremental">
<li><code>man 2 fork</code></li>
<li><code>man 2 wait</code></li>
<li><code>man 3 exec</code></li>
</ul></li>
</ul>
</section>
</section>
<script>
/*!	
* FitText.js 1.0 jQuery free version
*
* Copyright 2011, Dave Rupert http://daverupert.com 
* Released under the WTFPL license 
* http://sam.zoy.org/wtfpl/
* Modified by Slawomir Kolodziej http://slawekk.info
*
* Date: Tue Aug 09 2011 10:45:54 GMT+0200 (CEST)
*/
(function(){

  var addEvent = function (el, type, fn) {
    if (el.addEventListener)
      el.addEventListener(type, fn, false);
		else
			el.attachEvent('on'+type, fn);
  };
  
  var extend = function(obj,ext){
    for(var key in ext)
      if(ext.hasOwnProperty(key))
        obj[key] = ext[key];
    return obj;
  };

  window.fitText = function (el, kompressor, options) {

    var settings = extend({
      'minFontSize' : -1/0,
      'maxFontSize' : 1/0
    },options);

    var fit = function (el) {
      var compressor = kompressor || 1;

      var resizer = function () {
        el.style.fontSize = Math.max(Math.min(el.clientWidth / (compressor*10), parseFloat(settings.maxFontSize)), parseFloat(settings.minFontSize)) + 'px';
      };

      // Call once to set.
      resizer();

      // Bind events
      // If you have any js library which support Events, replace this part
      // and remove addEvent function (or use original jQuery version)
      addEvent(window, 'resize', resizer);
      addEvent(window, 'orientationchange', resizer);
    };

    if (el.length)
      for(var i=0; i<el.length; i++)
        fit(el[i]);
    else
      fit(el);

    // return set of elements
    return el;
  };
})();

    fitText(document.querySelectorAll('.level2'), 5);
    fitText(document.querySelectorAll('h1'), 2.5);

    document.querySelectorAll('p > img').forEach(e => e.parentNode.style.overflow="hidden");

</script>
  </body>
</html>
